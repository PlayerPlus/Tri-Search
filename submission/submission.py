
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
#################################################
# file to edit: notebook.ipynb͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁

import heapq
import os
import pickle
import math

# Credits if any͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
# 1)͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁 Warmup 1: I used the idea on how to preserve FIFO from https://docs.python.org/3/library/heapq.html.
# 2)͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
# 3)͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁


def return_your_name() -> str:
    """Return your first and last name from this function as a string"""
    # TODO: finish this function͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    return "Franz Adam"
    raise NotImplementedError



class PriorityQueue(object):
    """
    A queue structure where each element is served in order of priority.

    Elements in the queue are popped based on the priority with higher priority
    elements being served before lower priority elements.  If two elements have
    the same priority, they will be served in the order they were added to the
    queue.

    Traditionally priority queues are implemented with heaps, but there are any
    number of implementation options.

    (Hint: take a look at the module heapq)

    Attributes:
        queue (list): Nodes added to the priority queue.
    """

    def __init__(self):
        """Initialize a new Priority Queue."""

        self.queue = []
        self.counter = 0

    def pop(self):

        """
        Pop the top priority node from the queue.

        Returns:
        The node with the highest priority.
        """
        if self.size() == 0: #Check for empty
            raise IndexError("There are no items in the queue.")

        elif self.size() == 1: #I hardcoded this base case to simplify the implementation
            return_node = self.queue[0]
            self.queue.pop(0)

        else:
            return_node = self.queue[0]
            self.queue[0], heapify_index = self.queue[-1], 0 #Swap last and first item and then heapify it downwards
            self.queue.pop(-1) #Delete/Pop the last item

            index_left_child = heapify_index * 2 + 1 #Set up child indixes for heapified node
            index_right_child = heapify_index * 2 + 2

            #While left or right children exist to potentially swap
            while index_left_child < self.size() or index_right_child < self.size():
                smallest = heapify_index

                #If left child exists and < than heapified node or if == same and counter is smaller, set smallest to left child
                if index_left_child < self.size() and ((self.queue[index_left_child][0] < self.queue[smallest][0])
                                                       or ((self.queue[index_left_child][0] == self.queue[smallest][0])
                                                           and (self.queue[index_left_child][1] < self.queue[smallest][1]))):
                    smallest = index_left_child
                #Same for the right
                if index_right_child < self.size() and ((self.queue[index_right_child][0] < self.queue[smallest][0])
                                                       or ((self.queue[index_right_child][0] == self.queue[smallest][0])
                                                           and (self.queue[index_right_child][1] < self.queue[smallest][1]))):
                    smallest = index_right_child

                if smallest == heapify_index: #Break if heapified node
                    break

                # Swap with the smallest child
                self.queue[heapify_index], self.queue[smallest] = self.queue[smallest], self.queue[heapify_index]
                heapify_index = smallest

                index_left_child = heapify_index * 2 + 1
                index_right_child = heapify_index * 2 + 2

        return (return_node[0], return_node[2])

    def remove(self, node):
        """
        Remove a node from the queue.

        Hint: You might require this in ucs. However, you may
        choose not to use it or to define your own method.

        Args:
            node (tuple): The node to remove from the queue.
        """

        raise NotImplementedError

    def update(self, node, updated_priority):
        """
        Updates priority value of queue for A* and UCS to a smaller value if found in A*
        Loops through and updates.
        """
        loop = True

        for i in range(len(self.queue)):

            if (self.queue[i][2] == node) and (loop == True):
                #current = node
                self.queue[i][0] = updated_priority

                if i != 0:
                    current_index = i
                    parent_index = int((current_index - 1) // 2)

                    #Heapfiy up
                    while (((self.queue[current_index][0] <
                           self.queue[parent_index][0]) or (self.queue[current_index][0] ==
                           self.queue[parent_index][0] and self.queue[current_index][1] <
                           self.queue[parent_index][1])) and (current_index != 0)):

                        temp = self.queue[current_index]
                        self.queue[current_index] = self.queue[parent_index]
                        self.queue[parent_index] = temp

                        #update current and parent index
                        current_index = parent_index
                        if current_index != 0:
                           parent_index = int((parent_index - 1) // 2)

                    loop = False

    def __iter__(self):
        """Queue iterator."""

        return iter(sorted(self.queue))

    def __str__(self):
        """Priority Queue to string."""

        return 'PQ:%s' % self.queue

    def append(self, node):
        """
        Append a node to the queue.

        Args:
            node: Comparable Object to be added to the priority queue.

        I am building a min-heap as implementation. I conserve the min-heap property by heapifying every new node
        as long as it's smaller than it's parent.
        """
        #Restructure the tuple into a list to keep track of insertion order
        node_list = []
        node_list.append(node[0])
        node_list.append(self.counter)
        node_list.append(node[1])
        self.counter = self.counter + 1

        if self.size() == 0:
            self.queue.append(node_list)
        else:
            self.queue.append(node_list)
            new_node_index = self.size() - 1
            parent_index = int((new_node_index - 1) // 2)

            while((parent_index >= 0 and (node_list[0] < self.queue[parent_index][0]))
                  or (node_list[0] == self.queue[parent_index][0]
                      and node_list[1] < self.queue[parent_index][1])): #Heapify, while parent is bigger than inserted node, swap them

                temp_parent_node = self.queue[parent_index]
                self.queue[parent_index] = node_list
                self.queue[new_node_index] = temp_parent_node
                new_node_index = parent_index
                parent_index = int((parent_index -1) // 2) #Will reach -1 if new node has lowest priority, adding and conditional

        return "Append Successful"

    def __contains__(self, key):
        """
        Containment Check operator for 'in'

        Args:
            key: The key to check for in the queue.

        Returns:
            True if key is found in queue, False otherwise.
        """

        return key in [n[-1] for n in self.queue]

    def __eq__(self, other):
        """
        Compare this Priority Queue with another Priority Queue.

        Args:
            other (PriorityQueue): Priority Queue to compare against.

        Returns:
            True if the two priority queues are equivalent.
        """

        return self.queue == other.queue

    def size(self):
        """
        Get the current size of the queue.

        Returns:
            Integer of number of items in queue.
        """

        return len(self.queue)

    def clear(self):
        """Reset queue to empty (no nodes)."""

        self.queue = []

    def top(self):
        """
        Get the top item in the queue.

        Returns:
            The first item stored in the queue.
        """

        return self.queue[0]

    def get_nodes(self):
        nodes = []
        for i in range(len(self.queue)):
            nodes.append(self.queue[i][2])
        return nodes


def breadth_first_search(graph, start, goal):
    """
    Warm-up exercise: Implement breadth-first-search.

    See README.md for exercise description.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        start (str): Key for the start node.
        goal (str): Key for the end node.

    Returns:
        The best path as a list from the start to the goal node (including both).
    """

    if start == goal: return []

    bfs_queue = [start]
    visited = set()
    parent_dir = {start: None}
    path = []
    #cost = 0

    while len(bfs_queue) > 0:
        current = bfs_queue.pop(0)

        if current == goal:
            #path = []
            while current is not None:
                path.insert(0, current)
                current = parent_dir[current]
            return path

        temp_list = []

        for neighbor in graph.neighbors(current):
            if neighbor not in visited and neighbor not in parent_dir:

                if neighbor == goal:
                    parent_dir[neighbor] = current
                    current = neighbor
                    while current is not None:
                        path.insert(0, current)
                        current = parent_dir[current]
                    return path

                parent_dir[neighbor] = current
                temp_list.append(neighbor)

        temp_list = sorted(temp_list)
        #print(temp_list)
        for node in temp_list:
            bfs_queue.append(node)

    return None

    #print(graph.neighbors(start))
    #for key in graph.neighbors(start):
      #  print(key)

    #print("--------------", type(key), "----------" ,start ,"--------------")
    #raise NotImplementedError


def uniform_cost_search(graph, start, goal):
    """
    Warm-up exercise: Implement uniform_cost_search.

    See README.md for exercise description.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        start (str): Key for the start node.
        goal (str): Key for the end node.

    Returns:
        The best path as a list from the start to the goal node (including both).
    """
    #Check if start == goal, and if return []
    if start == goal:
        return []

    #Assign priority queue and add start as first element (root) with priority of 0
    priority_q = PriorityQueue()
    start_tuple = (0, start)
    priority_q.append(start_tuple)
    visited = set()
    parent_dir = {start: ["stop", 0]}
    path = []

    #While top in our priority queue is not equal to the goal node
    while (priority_q.top()[2] != goal):

        #Assign current node that is being explored, pop it off the priority queue
        #Initialize temporary list = []
        current = priority_q.pop()
        temp_list = []

        #Loop through neighbors of current that are not in visited
        for neighbor in graph.neighbors(current[1]):

            #Save them to a temporary list of tuples with
            #edge cost from current to neighbor + total edge cost to current

            if neighbor not in visited:

                total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parent_dir[current[1]][1]
                #Make current the parent of neighbor if not in parent_dir or smaller than existing entry
                if neighbor not in parent_dir:

                    #Make current the parent of neighbor
                    parent_dir[neighbor] = [current[1], total_edge_cost]

                    temp_cost = total_edge_cost
                    temp_list.append((temp_cost, neighbor))

                elif total_edge_cost < parent_dir[neighbor][1]:

                    parent_dir[neighbor] = [current[1], total_edge_cost]

                    #edge_diff = parent_dir[neighbor][1] - total_edge_cost
                    priority_q.update(neighbor, total_edge_cost)

        #TEST SET UP - START

        #print("Euclidean distance for p is: ", heuristic(graph, 'p','f'))
        #print("Euclidean distance for r is: ", heuristic(graph, 'r','f'))
        #print("Euclidean distance for s is: ", heuristic(graph, 's','f'))
        #print("Euclidean distance for f is: ", heuristic(graph, 'f','f'))
        #print("Euclidean distance for b is: ", heuristic(graph, 'b','f'))
        #print("Euclidean distance for c is: ", heuristic(graph, 'c','f'))

        #TEST SET UP - END


        #Mark current as visited
        visited.add(current[1])

        sort_and_append(priority_q, temp_list)
        #Sort the list alphabetically based on their tuple[1] value which will be a single character type string
        #sorted_tuples = sorted(temp_list, key=lambda x: x[1])

        #Append the list values to the priority queue, which will handle the prioritization
        #for element in sorted_tuples:
            #priority_q.append(element)

        #If top of priority queue == goal
        #backtrack from goal node to start using parent_directory and build path, return path
        if priority_q.top()[2] == goal:
            back_track = goal

            while back_track != "stop":
                path.insert(0, back_track)
                back_track = parent_dir[back_track][0]

            return path

    # TODO: finish this function!͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    #raise NotImplementedError

def sort_and_append(q_2_append_2, list_2_append):
    sorted_tuples = sorted(list_2_append, key=lambda x: x[1]) #Sort alphabetically
    for element in sorted_tuples: #Append to priority queue
        q_2_append_2.append(element)


def null_heuristic(graph, v, goal):
    """
    Null heuristic used as a base line.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        v (str): Key for the node to calculate from.
        goal (str): Key for the end node to calculate to.

    Returns:
        0
    """

    return 0


def euclidean_dist_heuristic(graph, u, v):
    """
    Warm-up exercise: Implement the euclidean distance heuristic.

    See README.md for exercise description.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        u (str): Key for the first node to calculate from.
        v (str): Key for the second node to calculate to.

    Returns:
        Euclidean distance between the `u` node and the `v` node
        Round the result to 3 decimal places (if applicable)
    """

   # print(graph.nodes[u]['pos'])
    x_diff = graph.nodes[u]['pos'][0] - graph.nodes[v]['pos'][0]
    y_diff = graph.nodes[u]['pos'][1] - graph.nodes[v]['pos'][1]

    return round(math.sqrt(x_diff**2 + y_diff**2), 3)
    # TODO: finish this function!͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    #raise NotImplementedError


def a_star(graph, start, goal, heuristic=euclidean_dist_heuristic):
    """
    Warm-up exercise: Implement A* algorithm.

    See README.md for exercise description.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        start (str): Key for the start node.
        goal (str): Key for the end node.
        heuristic: Function to determine distance heuristic.
            Default: euclidean_dist_heuristic.

    Returns:
        The best path as a list from the start to the goal node (including both).
    """

    #Check if start == goal, and if return []
    if start == goal:
        return []

    #Assign priority queue and add start as first element (root) with priority of 0 + euclidean distance to goal (heuristic)
    priority_q = PriorityQueue()
    start_tuple = (heuristic(graph, start, goal), start)
    priority_q.append(start_tuple)
    visited = set()
    parent_dir = {start: ["stop", 0]}
    path = []

    #While top in our priority queue is not equal to the goal node
    while (priority_q.top()[2] != goal):

        #Assign current node that is being explored, pop it off the priority queue
        #Initialize temporary list = []
        current = priority_q.pop()
        temp_list = []

        #Loop through neighbors of current that are not in visited
        for neighbor in graph.neighbors(current[1]):

            #Save them to a temporary list of tuples with
            #(edge cost from current to neighbor + euclidean distance from neighbor to goal (heuristic), node)

            if neighbor not in visited:

                total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parent_dir[current[1]][1]
                #Make current the parent of neighbor if not in parent_dir or smaller than existing entry
                if neighbor not in parent_dir:

                    #Make current the parent of neighbor
                    parent_dir[neighbor] = [current[1], total_edge_cost]

                    temp_cost = total_edge_cost + heuristic(graph, neighbor, goal)
                    temp_list.append((temp_cost, neighbor))

                elif total_edge_cost < parent_dir[neighbor][1]:

                    parent_dir[neighbor] = [current[1], total_edge_cost]

                    #edge_diff = parent_dir[neighbor][1] - total_edge_cost
                    priority_q.update(neighbor, total_edge_cost + heuristic(graph, neighbor, goal))

        #TEST SET UP - START
        #print("Euclidean distance for p is: ", heuristic(graph, 'p','f'))
        #print("Euclidean distance for r is: ", heuristic(graph, 'r','f'))
        #print("Euclidean distance for s is: ", heuristic(graph, 's','f'))
        #print("Euclidean distance for f is: ", heuristic(graph, 'f','f'))
        #print("Euclidean distance for b is: ", heuristic(graph, 'b','f'))
        #print("Euclidean distance for c is: ", heuristic(graph, 'c','f'))
        #print(priority_q.get_nodes())
        #TEST SET UP - END


        #Mark current as visited
        visited.add(current[1])

        #Sort the list alphabetically based on their tuple[1] value which will be a single character type string
        sorted_tuples = sorted(temp_list, key=lambda x: x[1])

        #Append the list values to the priority queue, which will handle the prioritization
        for element in sorted_tuples:
            priority_q.append(element)

        #If top of priority queue == goal
        #backtrack from goal node to start using parent_directory and build path, return path
        if priority_q.top()[2] == goal:
            back_track = goal

            while back_track != "stop":
                path.insert(0, back_track)
                back_track = parent_dir[back_track][0]

            return path

    #raise NotImplementedError


def bidirectional_ucs(graph, start, goal):
    """
    Exercise 1: Bidirectional Search.

    See README.md for exercise description.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        start (str): Key for the start node.
        goal (str): Key for the end node.

    Returns:
        The best path as a list from the start to the goal node (including both).
    """

    #If start == goal, return [], elif start is neighbor of goal, return [start, goal]
    if start == goal: return []

    #Initialize 2 priority qs and visited lists, forward and backward
    q_forward, q_backward = PriorityQueue(), PriorityQueue()
    visited_f, visited_b = set(), set()
    forward = True

    q_forward.append((0, start))
    q_backward.append((0, goal))

    #Initialize parent directories
    parents_f = {start: ["stop", 0]}
    parents_b = {goal: ["stop", 0]}

    # SET UP COMPLETE - NOW TO THE GOOD STUFF

    while (not visited_f.intersection(visited_b)): #while explored sets from forward and backward don't intersect
        #Forward
        if forward:
            current = q_forward.pop()
            temp_list = []
            for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
                if neighbor not in visited_f:
                    total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_f[current[1]][1]
                    if neighbor not in parents_f: #If neighbor has no parent yet
                        parents_f[neighbor] = [current[1], total_edge_cost] #Assign parent
                        temp_list.append((total_edge_cost, neighbor)) #Append to list
                    elif total_edge_cost < parents_f[neighbor][1]: #If parent exists, but we found a cheaper path
                        parents_f[neighbor] = [current[1], total_edge_cost] #Update parent
                        q_forward.update(neighbor, total_edge_cost) #Update queue

            visited_f.add(current[1]) #Add to forward set of visited
            sort_and_append(q_forward, temp_list) #Sort list alphabetically and append to forward queue

            forward = False

        #Backward
        else:
            current = q_backward.pop()
            temp_list = []
            for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
                if neighbor not in visited_b:
                    total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_b[current[1]][1]
                    if neighbor not in parents_b: #If neighbor has no parent yet
                        parents_b[neighbor] = [current[1], total_edge_cost] #Assign parent
                        temp_list.append((total_edge_cost, neighbor)) #Append to list
                    elif total_edge_cost < parents_b[neighbor][1]: #If parent exists, but we found a cheaper path
                        parents_b[neighbor] = [current[1], total_edge_cost] #Update parent
                        q_backward.update(neighbor, total_edge_cost) #Update queue

            visited_b.add(current[1]) #Add to forward set of visited
            sort_and_append(q_backward, temp_list) #Sort list alphabetically and append to forward queue

            forward = True

        #print(visited_b, visited_f)

    #As while loop stopped, explored sets intersect on one element
    intersection_node = next(iter(visited_f.intersection(visited_b))) #Find intersection node

    ###
    crossover_points = list(visited_f.intersection(set((q_backward.get_nodes() + list(visited_b)))))
    #print("Intersection node: ", intersection_node)
    #print("test crossover fct input, should be set", set((q_backward.get_nodes() + list(visited_b))))
    #print("see crossover points: ",crossover_points)

    path_costs = []
    for point in crossover_points:
        path_costs.append([point, parents_b[point][1] + parents_f[point][1]])

    path_costs = sorted(path_costs, key=lambda x: x[1])
    #path_costs = [sublist for sublist in path_costs if intersection_node not in sublist[0]]
    path_costs = [sublist for sublist in path_costs if intersection_node != sublist[0]]
    #print("See sorted path costs list: ", path_costs)

    intersection_cost = parents_b[intersection_node][1] + parents_f[intersection_node][1]
    #print("intersection cost: ", intersection_cost)
    #print("Path cost: ", path_costs[0][1])

    if intersection_cost > path_costs[0][1]:
        #print("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
        forward_path = backtrack_and_append(path_costs[0][0], parents_f)
        backward_path = backtrack_and_append(path_costs[0][0], parents_b)

        backward_path = backward_path[:-1] #Remove last element
        backward_path.reverse()

        path = forward_path + backward_path

        return path


    forward_path = backtrack_and_append(intersection_node, parents_f)
    backward_path = backtrack_and_append(intersection_node, parents_b)

    backward_path = backward_path[:-1] #Remove last element
    backward_path.reverse()

    path = forward_path + backward_path

    #Once intersection is found, assign upper bound to find an alternative intersection point to be sum of edge costs
    #from the parent of the intersection node for forward and backward seearch to the intersection node
    #The lower bound will be not important but the edge cost form parent of intersection to intersection
    #for the respective search.

    #Save total path cost to be sum of total edge cost to intersection for both searches

    #Find all potential crossover points to be the intersection of nodes between the set of
    #forward explroed (visited_f and)
    #the union of backward explored (visited_b) and backsearch frontier (q_backward)

    #Calculate the total path cost for each crossover point = sum(cost to this point from forward and backward)

    #For the lowest cost crossover point, explore it from the backward frontier

    return path

    #raise NotImplementedError

def sort_and_append(q_2_append_2, list_2_append):
    sorted_tuples = sorted(list_2_append, key=lambda x: x[1]) #Sort alphabetically
    for element in sorted_tuples: #Append to priority queue
        q_2_append_2.append(element)

def backtrack_and_append(intersection_node, parent_directory):
    path = []
    back_track = intersection_node
    while back_track != "stop":
        path.insert(0, back_track)
        back_track = parent_directory[back_track][0]
    return path


def bidirectional_a_star(graph, start, goal,
                         heuristic=euclidean_dist_heuristic):
    """
    Exercise 2: Bidirectional A*.

    See README.md for exercise description.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        start (str): Key for the start node.
        goal (str): Key for the end node.
        heuristic: Function to determine distance heuristic.
            Default: euclidean_dist_heuristic.

    Returns:
        The best path as a list from the start to the goal node (including both).
    """
    #Start condition and initializations
    if start == goal: return []

    q_forward, q_backward = PriorityQueue(), PriorityQueue()
    visited_f, visited_b = set(), set()
    forward = True
    q_forward.append((0, start))
    q_backward.append((0, goal))
    parents_f = {start: ["stop", 0]}
    parents_b = {goal: ["stop", 0]}

    while (not visited_f.intersection(visited_b)): #while explored sets from forward and backward don't intersect

        if forward:
            current = q_forward.pop()
            temp_list = []
            for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
                if neighbor not in visited_f:
                    total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_f[current[1]][1]
                    if neighbor not in parents_f: #If neighbor has no parent yet
                        parents_f[neighbor] = [current[1], total_edge_cost] #Assign parent
                        temp_cost = total_edge_cost + heuristic(graph, neighbor, goal)
                        temp_list.append((temp_cost, neighbor)) #Append to list
                    elif total_edge_cost < parents_f[neighbor][1]: #If parent exists, but we found a cheaper path
                        parents_f[neighbor] = [current[1], total_edge_cost] #Update parent
                        q_forward.update(neighbor, temp_cost) #Update queue

            visited_f.add(current[1]) #Add to forward set of visited
            sort_and_append(q_forward, temp_list) #Sort list alphabetically and append to forward queue

            forward = False

        #Backward
        else:
            current = q_backward.pop()
            temp_list = []
            for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
                if neighbor not in visited_b:
                    total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_b[current[1]][1]
                    if neighbor not in parents_b: #If neighbor has no parent yet
                        parents_b[neighbor] = [current[1], total_edge_cost] #Assign parent
                        temp_cost = total_edge_cost + heuristic(graph, neighbor, start)
                        temp_list.append((temp_cost, neighbor)) #Append to list
                    elif total_edge_cost < parents_b[neighbor][1]: #If parent exists, but we found a cheaper path
                        parents_b[neighbor] = [current[1], total_edge_cost] #Update parent
                        q_backward.update(neighbor, temp_cost) #Update queue

            visited_b.add(current[1]) #Add to forward set of visited
            sort_and_append(q_backward, temp_list) #Sort list alphabetically and append to forward queue

            forward = True

        #print(visited_b, visited_f)

    #As while loop stopped, explored sets intersect on one element
    intersection_node = next(iter(visited_f.intersection(visited_b))) #Find intersection node

    ###
    crossover_points = list(visited_f.intersection(set((q_backward.get_nodes() + list(visited_b)))))
    #print("Intersection node: ", intersection_node)
    #print("test crossover fct input, should be set", set((q_backward.get_nodes() + list(visited_b))))
    #print("see crossover points: ",crossover_points)

    path_costs = []
    for point in crossover_points:
        path_costs.append([point, parents_b[point][1] + parents_f[point][1]])

    path_costs = sorted(path_costs, key=lambda x: x[1])
    #path_costs = [sublist for sublist in path_costs if intersection_node not in sublist[0]]
    path_costs = [sublist for sublist in path_costs if intersection_node != sublist[0]]
    #print("See sorted path costs list: ", path_costs)

    intersection_cost = parents_b[intersection_node][1] + parents_f[intersection_node][1]
    #print("intersection cost: ", intersection_cost)
    #print("Path cost: ", path_costs[0][1])

    if intersection_cost > path_costs[0][1]:
        #print("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
        forward_path = backtrack_and_append(path_costs[0][0], parents_f)
        backward_path = backtrack_and_append(path_costs[0][0], parents_b)

        backward_path = backward_path[:-1] #Remove last element
        backward_path.reverse()

        path = forward_path + backward_path

        return path


    forward_path = backtrack_and_append(intersection_node, parents_f)
    backward_path = backtrack_and_append(intersection_node, parents_b)

    backward_path = backward_path[:-1] #Remove last element
    backward_path.reverse()

    path = forward_path + backward_path

    #Once intersection is found, assign upper bound to find an alternative intersection point to be sum of edge costs
    #from the parent of the intersection node for forward and backward seearch to the intersection node
    #The lower bound will be not important but the edge cost form parent of intersection to intersection
    #for the respective search.

    #Save total path cost to be sum of total edge cost to intersection for both searches

    #Find all potential crossover points to be the intersection of nodes between the set of
    #forward explroed (visited_f and)
    #the union of backward explored (visited_b) and backsearch frontier (q_backward)

    #Calculate the total path cost for each crossover point = sum(cost to this point from forward and backward)

    #For the lowest cost crossover point, explore it from the backward frontier

    return path

    #raise NotImplementedError

def sort_and_append(q_2_append_2, list_2_append):
    sorted_tuples = sorted(list_2_append, key=lambda x: x[1]) #Sort alphabetically
    for element in sorted_tuples: #Append to priority queue
        q_2_append_2.append(element)

def backtrack_and_append(intersection_node, parent_directory):
    path = []
    back_track = intersection_node
    while back_track != "stop":
        path.insert(0, back_track)
        back_track = parent_directory[back_track][0]
    return path
    # TODO: finish this function!͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    #raise NotImplementedError


def tridirectional_search(graph, goals):

    ### SET UP
    if goals[0] == goals[1] == goals[2]: return []
    #test = False
    #if goals == ['b', 'm', 'o']:
        #test = True
    q1, q2, q3 = PriorityQueue(), PriorityQueue(), PriorityQueue()
    v1, v2, v3 = set(), set(), set()
    one, two, no_need_to_compare = True, True, False

    q1.append((0, goals[0]))
    q2.append((0, goals[1]))
    q3.append((0, goals[2]))

    parents_1 = {goals[0]: ["stop", 0]}
    parents_2 = {goals[1]: ["stop", 0]}
    parents_3 = {goals[2]: ["stop", 0]}

    ###############################

    ### INITIAL LOOP TO FIND FIRST INTERSECTION

    while ((q1.top()[2] not in v1.union(v2, v3)) and (q2.top()[2] not in v1.union(v2, v3)) and
           (q3.top()[2] not in v1.union(v2, v3))):

        if one: #Search 1
            current = q1.pop()
            temp_list = []


            if q1.size() != 0:
                if q1.top()[2] in v1.union(v2, v3):
                    v1.add(current[1]) #Add to forward set of visited
                    break

            for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
                if neighbor not in v1:
                    total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_1[current[1]][1]
                    if neighbor not in parents_1: #If neighbor has no parent yet
                        parents_1[neighbor] = [current[1], total_edge_cost] #Assign parent
                        temp_list.append((total_edge_cost, neighbor)) #Append to list
                    elif total_edge_cost < parents_1[neighbor][1]: #If parent exists, but we found a cheaper path
                        parents_1[neighbor] = [current[1], total_edge_cost] #Update parent
                        q1.update(neighbor, total_edge_cost) #Update queue
            v1.add(current[1]) #Add to forward set of visited
            sort_and_append(q1, temp_list) #Sort list alphabetically and append to queue
            one = False
        elif two: #Search 2
            current = q2.pop()
            temp_list = []

            if q2.size() != 0:
                if q2.top()[2] in v1.union(v2, v3):
                    v2.add(current[1]) #Add to forward set of visited
                    break

            for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
                if neighbor not in v2:
                    total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_2[current[1]][1]
                    if neighbor not in parents_2: #If neighbor has no parent yet
                        parents_2[neighbor] = [current[1], total_edge_cost] #Assign parent
                        temp_list.append((total_edge_cost, neighbor)) #Append to list
                    elif total_edge_cost < parents_2[neighbor][1]: #If parent exists, but we found a cheaper path
                        parents_2[neighbor] = [current[1], total_edge_cost] #Update parent
                        q2.update(neighbor, total_edge_cost) #Update queue
            v2.add(current[1]) #Add to forward set of visited
            sort_and_append(q2, temp_list) #Sort list alphabetically and append to queue
            two = False
        else: #Search 3
            current = q3.pop()
            temp_list = []

            if q3.size() != 0:
                if q3.top()[2] in v1.union(v2, v3):
                    v3.add(current[1]) #Add to forward set of visited
                    break

            for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
                if neighbor not in v3:
                    total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_3[current[1]][1]
                    if neighbor not in parents_3: #If neighbor has no parent yet
                        parents_3[neighbor] = [current[1], total_edge_cost] #Assign parent
                        temp_list.append((total_edge_cost, neighbor)) #Append to list
                    elif total_edge_cost < parents_3[neighbor][1]: #If parent exists, but we found a cheaper path
                        parents_3[neighbor] = [current[1], total_edge_cost] #Update parent
                        q3.update(neighbor, total_edge_cost) #Update queue
            v3.add(current[1]) #Add to forward set of visited
            sort_and_append(q3, temp_list) #Sort list alphabetically and append to queue
            one = True
            two = True
    ####################################

    ### OPTIMIZE FIRST PATH AB
    met = who_met_3(q1, q2, q3, v1, v2, v3, parents_1, parents_2, parents_3)
    eval('v' + str(met[1])).add(met[0])
    eval('v' + str(met[2])).add(met[0])
    ab_intersect = met[0]
    crossover_points = list(eval('v' + str(met[1])).intersection(set((eval('q' + str(met[2])).get_nodes() +
                                                                             list(eval('v' + str(met[2])))))))
    path_costs = []
    for point in crossover_points:
        path_costs.append([point, eval('parents_' + str(met[2]))[point][1] +
                           eval('parents_' + str(met[1]))[point][1]])
    path_costs = sorted(path_costs, key=lambda x: x[1])
    path_costs = [sublist for sublist in path_costs if ab_intersect != sublist[0]]
    intersection_cost = eval('parents_' + str(met[2]))[met[0]][1] + eval('parents_' + str(met[1]))[met[0]][1]
    if len(path_costs) != 0:
        if intersection_cost > path_costs[0][1]:
            ab_intersect = path_costs[0][0]
            eval('v' + str(met[1])).add(ab_intersect)
            eval('v' + str(met[2])).add(ab_intersect)
    ab_path_cost = eval('parents_' + str(met[2]))[ab_intersect][1] + eval('parents_' + str(met[1]))[ab_intersect][1]
    #####################################

    ### Continue Search with 3rd Search I
    temp1, temp2 = [met[1], met[2]], ['1', '2','3']
    result = [item for item in temp2 if item not in temp1] #result contains leftover search number
    q_continue = eval('q' + str(result[0]))
    parents_continue = eval('parents_' + str(result[0]))

    while (q_continue.top()[2] not in eval('v' + str(met[1])).union(eval('v' + str(met[2])))):
        current = q_continue.pop()
        temp_list = []
        """
        if q_continue.size() != 0:
            if q_continue.top()[2] in eval('v' + str(met[1])).union(eval('v' + str(met[2]))):
                sort_and_append(q_continue, temp_list)
                break
         """
        for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
            total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_continue[current[1]][1]
            if neighbor not in parents_continue: #If neighbor has no parent yet
                parents_continue[neighbor] = [current[1], total_edge_cost] #Assign parent
                temp_list.append((total_edge_cost, neighbor)) #Append to list
            elif total_edge_cost < parents_continue[neighbor][1]: #If parent exists, but we found a cheaper path
                parents_continue[neighbor] = [current[1], total_edge_cost] #Update parent
                q_continue.update(neighbor, total_edge_cost) #Update queue
        sort_and_append(q_continue, temp_list) #Sort list alphabetically and append to queue
    #####################################

    ### OPTIMIZE SECOND PATH C -
    c_search_x_initial = who_met_2(q_continue.top()[2], eval('v' + str(met[1])), met[1], eval('v' + str(met[2])), met[2])
    crossover_points = list(eval('v' + str(c_search_x_initial)).intersection(set((q_continue.get_nodes()))))
    path_costs = []
    for point in crossover_points:
        path_costs.append([point, parents_continue[point][1] + eval('parents_' + str(c_search_x_initial))[point][1]])
    path_costs = sorted(path_costs, key=lambda x: x[1])
    path_costs = [sublist for sublist in path_costs if q_continue.top()[2] != sublist[0]]
    intersection_cost = parents_continue[q_continue.top()[2]][1] + eval('parents_' + str(c_search_x_initial))[q_continue.top()[2]][1]
    intersect_node_c_x_initial = q_continue.top()[2]
    if len(path_costs) != 0:
        if intersection_cost > path_costs[0][1]:
            intersect_node_c_x_initial = path_costs[0][0] #Update intersect node
    c_x_path_cost_1 = parents_continue[intersect_node_c_x_initial][1] + eval('parents_' + str(c_search_x_initial))[intersect_node_c_x_initial][1]
    ######################################

    ### Continue Search with 3rd Search II
    options = [met[1], met[2]]
    c_search_x_second = [item for item in options if item != c_search_x_initial][0]

    if q_continue.top()[0] >= max(c_x_path_cost_1, ab_path_cost):
        no_need_to_compare = True

    while (q_continue.top()[2] not in eval('v' + str(c_search_x_second))) and not no_need_to_compare:
        if q_continue.size() == 1:
            if q_continue.top()[0] >= max(c_x_path_cost_1, ab_path_cost):
                break

        current = q_continue.pop()
        temp_list = []

        if q_continue.size() != 0:
            if q_continue.top()[0] >= max(c_x_path_cost_1, ab_path_cost):
                break

        for neighbor in graph.neighbors(current[1]): #Loop through neighbors of current that are not in visited
            total_edge_cost = graph.get_edge_weight(current[1], neighbor) + parents_continue[current[1]][1]
            if neighbor not in parents_continue: #If neighbor has no parent yet
                parents_continue[neighbor] = [current[1], total_edge_cost] #Assign parent
                temp_list.append((total_edge_cost, neighbor)) #Append to list
            elif total_edge_cost < parents_continue[neighbor][1]: #If parent exists, but we found a cheaper path
                parents_continue[neighbor] = [current[1], total_edge_cost] #Update parent
                q_continue.update(neighbor, total_edge_cost) #Update queue
        sort_and_append(q_continue, temp_list) #Sort list alphabetically and append to queue

    if q_continue.top()[0] >= max(c_x_path_cost_1, ab_path_cost):
        no_need_to_compare = True
    #######################################

    ### OPTIMIZE THIRD PATH C - (if applicable)
    if not no_need_to_compare:
        crossover_points = list(eval('v' + str(c_search_x_second)).intersection(set((q_continue.get_nodes()))))
        path_costs = []
        intersect_node_c_x_second = q_continue.top()[2]
        for point in crossover_points:
            path_costs.append([point, parents_continue[point][1] + eval('parents_' + str(c_search_x_second))[point][1]])
        path_costs = sorted(path_costs, key=lambda x: x[1])
        path_costs = [sublist for sublist in path_costs if intersect_node_c_x_second != sublist[0]]
        if not no_need_to_compare:
            intersection_cost = parents_continue[intersect_node_c_x_second][1] + eval('parents_' + str(c_search_x_second))[intersect_node_c_x_second][1]
            if len(path_costs) != 0:
                if intersection_cost > path_costs[0][1]:
                    intersect_node_c_x_second = path_costs[0][0] #Update intersect node
            c_x_path_cost_2 = parents_continue[intersect_node_c_x_second][1] + eval('parents_' + str(c_search_x_second))[intersect_node_c_x_second][1]
    ######################################

    ### Build Path
    #Case 1: CB was determined to be longer than max of (AB, AC) and therefore never searched for
    if no_need_to_compare:
        c_path = backtrack_and_append(intersect_node_c_x_initial, parents_continue)
        temp_path = backtrack_and_append(intersect_node_c_x_initial, eval('parents_' + str(c_search_x_initial)))
        temp_path.reverse()
        c_path = c_path + temp_path
        if c_search_x_initial == met[1]:
            ab_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[1])))
            b_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[2])))
            b_path.reverse()
            ab_path = ab_path + b_path
        else:
            ab_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[2])))
            b_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[1])))
            b_path.reverse()
            ab_path = ab_path + b_path

        full_path = c_path + ab_path
        result_path = filter_nodes(full_path)
        return result_path

    #Case 2: CB was found. If CA <= CB
    if c_x_path_cost_1 <= c_x_path_cost_2:
        c_path = backtrack_and_append(intersect_node_c_x_initial, parents_continue)
        temp_path = backtrack_and_append(intersect_node_c_x_initial, eval('parents_' + str(c_search_x_initial)))
        temp_path.reverse()
        c_path_1 = c_path + temp_path
        if (c_x_path_cost_2 < ab_path_cost) and (c_x_path_cost_1 != c_x_path_cost_2):
            temp1 = backtrack_and_append(intersect_node_c_x_second, eval('parents_' + str(c_search_x_second)))
            temp2 = backtrack_and_append(intersect_node_c_x_second, parents_continue)
            temp2.reverse()
            c_path_2 = temp1 + temp2
            full_path = c_path_2 + c_path_1
            result_path = filter_nodes(full_path)
            return result_path
        else:
            if c_search_x_initial == met[1]:
                ab_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[1])))
                b_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[2])))
                b_path.reverse()
                ab_path = ab_path + b_path
            else:
                ab_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[2])))
                b_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[1])))
                b_path.reverse()
                ab_path = ab_path + b_path
            full_path = c_path_1 + ab_path
            result_path = filter_nodes(full_path)
            return result_path

    #Case 3: CB was found. If CA > CB
    c_path = backtrack_and_append(intersect_node_c_x_second, parents_continue)
    temp_path = backtrack_and_append(intersect_node_c_x_second, eval('parents_' + str(c_search_x_second)))
    temp_path.reverse()
    c_path = c_path + temp_path
    if (c_x_path_cost_1 < ab_path_cost) and (c_x_path_cost_1 != c_x_path_cost_2):
        temp1 = backtrack_and_append(intersect_node_c_x_initial, eval('parents_' + str(c_search_x_initial)))
        temp2 = backtrack_and_append(intersect_node_c_x_initial, parents_continue)
        temp2.reverse()
        c_path_2 = temp1 + temp2
        full_path = c_path_2 + c_path
        result_path = filter_nodes(full_path)
        return result_path
    else:
        if c_search_x_second == met[1]:
            ab_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[1])))
            b_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[2])))
            b_path.reverse()
            ab_path = ab_path + b_path
        else:
            ab_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[2])))
            b_path = backtrack_and_append(ab_intersect, eval('parents_' + str(met[1])))
            b_path.reverse()
            ab_path = ab_path + b_path

        full_path = c_path + ab_path
        result_path = filter_nodes(full_path)
        return result_path

##########################################
##########################################
##########################################
def filter_nodes(full_path):
    result = []
    for i in range(len(full_path) - 1):
        if full_path[i] != full_path[i + 1]:
            result.append(full_path[i])
    result.append(full_path[-1])
    return result
def sort_and_append(q_2_append_2, list_2_append):
    sorted_tuples = sorted(list_2_append, key=lambda x: x[1]) #Sort alphabetically
    for element in sorted_tuples: #Append to priority queue
        q_2_append_2.append(element)

def backtrack_and_append(intersection_node, parent_directory):
    path, counter = [], 0
    back_track = intersection_node
    while back_track != "stop":
        path.insert(0, back_track)
        back_track = parent_directory[back_track][0]
    return path

def who_met_2(q1, v2,num2, v3,num3):
    if q1 in v2:
        return str(num2)
    elif q1 in v3:
        return str(num3)
    return None

def who_met_3(q1, q2, q3, v1, v2, v3, p1, p2, p3):
    intersections = []
    if q1.top()[2] in v2:
        intersections.append((q1.top()[2], '1', '2', p1[q1.top()[2]][1] + p2[q1.top()[2]][1]))
    if q1.top()[2] in v3:
        intersections.append((q1.top()[2], '1', '3', p1[q1.top()[2]][1] + p3[q1.top()[2]][1]))
    if q2.top()[2] in v1:
        intersections.append((q2.top()[2], '2', '1', p2[q2.top()[2]][1] + p1[q2.top()[2]][1]))
    if q2.top()[2] in v3:
        intersections.append((q2.top()[2], '2', '3', p2[q2.top()[2]][1] + p3[q2.top()[2]][1]))
    if q3.top()[2] in v1:
        intersections.append((q3.top()[2], '3', '1', p3[q3.top()[2]][1] + p1[q3.top()[2]][1]))
    if q3.top()[2] in v2:
        intersections.append((q3.top()[2], '3', '2', p3[q3.top()[2]][1] + p2[q3.top()[2]][1]))
    if intersections:
        return min(intersections, key=lambda x: x[3])
    else:
        return None


def compute_landmarks(graph):
    """
    (Optional)
    Feel free to implement this method for computing landmarks. We will call
    tridirectional_upgraded() with the object returned from this function.

    Args:
        graph (ExplorableGraph): Undirected graph to search.

    Returns:
    List with not more than 4 computed landmarks.
    """
    # TODO: finish this function͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    return None


def custom_heuristic(graph, u, v):
    """
        Feel free to use this method to try and work with different heuristics and come up with a better search algorithm.
        Args:
            graph (ExplorableGraph): Undirected graph to search.
            u (str): Key for the first node to calculate from.
            v (str): Key for the second node to calculate to.
        Returns:
            Custom heuristic distance between `v` node and `goal` node
        """
    pass


def tridirectional_upgraded(graph, goals, heuristic=euclidean_dist_heuristic, landmarks=None):
    """
    Exercise 4: Upgraded Tridirectional Search

    See README.MD for exercise description.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        goals (list): Key values for the 3 goals
        heuristic: Function to determine distance heuristic.
            Default: euclidean_dist_heuristic.
        landmarks: Iterable containing landmarks pre-computed in compute_landmarks()
            Default: None

    Returns:
        The best path as a list from one of the goal nodes (including both of
        the other goal nodes).
    """
    # TODO: finish this function͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    raise NotImplementedError


def haversine_dist_heuristic(graph, v, goal):
    """
    Note: This provided heuristic is for the Atlanta race.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        v (str): Key for the node to calculate from.
        goal (str): Key for the end node to calculate to.

    Returns:
        Haversine distance between `v` node and `goal` node
    """

    #Load latitude and longitude coordinates in radians:͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    vLatLong = (math.radians(graph.nodes[v]["pos"][0]), math.radians(graph.nodes[v]["pos"][1]))
    goalLatLong = (math.radians(graph.nodes[goal]["pos"][0]), math.radians(graph.nodes[goal]["pos"][1]))

    #Now we want to execute portions of the formula:͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    constOutFront = 2*6371 #Radius of Earth is 6,371 kilometers
    term1InSqrt = (math.sin((goalLatLong[0]-vLatLong[0])/2))**2 #First term inside sqrt
    term2InSqrt = math.cos(vLatLong[0])*math.cos(goalLatLong[0])*((math.sin((goalLatLong[1]-vLatLong[1])/2))**2) #Second term
    return constOutFront*math.asin(math.sqrt(term1InSqrt+term2InSqrt)) #Straight application of formula


def load_data(graph, time_left):
    """
    Feel free to implement this method. We'll call it only once
    at the beginning of the Race, and we'll pass the output to your custom_search function.
    graph: a networkx graph
    time_left: function you can call to keep track of your remaining time.
        usage: time_left() returns the time left in milliseconds.
        the max time will be 10 minutes.

    * To get a list of nodes, use graph.nodes()
    * To get node neighbors, use graph.neighbors(node)
    * To get edge weight, use graph.get_edge_weight(node1, node2)
    """

    # nodes = graph.nodes()͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    return None


def custom_search(graph, start, goal, data=None):
    """
    Race!: Implement your best search algorithm here to compete against the
    other student agents.

    If you implement this function and submit your code to Gradescope, you'll be
    registered for the Race!

    See README.md for exercise description.

    Args:
        graph (ExplorableGraph): Undirected graph to search.
        start (str): Key for the start node.
        goal (str): Key for the end node.
        data :  Data used in the custom search.
            Will be passed your data from load_data(graph).
            Default: None.

    Returns:
        The best path as a list from the start to the goal node (including both).
    """

    # TODO: finish this function!͏󠄂͏️͏󠄌͏󠄎͏󠄎͏󠄊͏󠄁
    raise NotImplementedError